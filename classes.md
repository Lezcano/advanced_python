# Short notes on the classes

## Class 0: Generalities
- The Zen of Python
    - `import this`
- Duck Typing
    - If it walks like a duck and it quacks like a duck, then it must be a duck
- A word on efficiency
    - Premature optimisation is the root of all evil
    - Premature pesimisation vs. premature optimisation
    - If you do care:
        - Vectorise and measure
        - Rule of thumb: Shorter (in number of calls) is better
- A word on inheritance
    - Think about it as decorating the class

## Class 1: Flat containers
- [p.20 UML diagram]
- List comprehensions
    - Syntax
    - Their values are local: `x = 3; [x for x in range(5)]`
    - Prefer list comprehension over `map` / `filter`
    - Cartesian product.
- Generator expressions [More in Chapter 14]
    - Syntax
    - Example in for loop and min function
- Tuples
    - Syntax
    - As immutable lists
    - As records: Less space than an object
    - Unpacking (as with any sequence)
        - Swap two variables
        - Star operator for calling functions with tuple (Ex.)
        - Return multiple values (Ex.)
        - Nesting works fine (Ex.)
    - `Card = collections.namedtuple('Card', ['rank', 'suit'])`
- Slicing
    - Syntax (Ex capicua: a == a[::-1])
    - Slice object. `seq.__getitem___(slice(start, stop, step))`
    - Multidimensional slicing. [`my_seq.py`]
    - Ellipsis (Numpy)
    - Assigning to slice: rhs has to be an iterable
- Sequences
    - Operator + and *
        - Lists of lists and operator *. [`operator_mul.py`, `fix_operator_mul.py`]
        - Mention empty list of lists
    - Operator += and *=: Mutable vs immutable [`mutable_vs_immutable.py`]
        - Puzzle [`puzzle.py`]: Putting mutable objects in immutable objects is not good
    - Sorted sequences
        - `.sort()` vs `sorted`
        - `bisect`, `insort`
- A word on numpy / scipy / torch
- Deques
    - Efficiency and thread-safe
    - Rotate and append left / right
    - Removing from middle is slow
    - Mention heapq module and asyncio.PriorityQueue

## Class 2: Mappings
- Dictionaries
    - Hashable objects:
        - Implements `__eq__` and `__hash__` and `a == b` => `hash(a) == hash(b)`
            - If you impelment `__eq__` you also have to implement `__hash__`
        - An immutable object is "always" hashable. A list is not.
    - `dict` comprehensions
    - `__getitem__` just called by `operator[]`, not by get or `__contains__`.
    - Don't look up more than you need to
        - `.get(key, default)` returns None or the element, but it is not inserted
        - `.setdefault()`: If not, the element is inserted
        - `collections.defaultdict(list)`: Just default value for `__getitem__`
        - `__missing__`
    - Other dicts:
        - `collections.OrderedDict`: Keeps an order on the keys
        - `collections.ChainMap`: "Flattens" a few dicts into one
        - `collections.Counter`
        - `UserDicts`: Just override magic methods and you're good. [Ex. strkeydict.py]
    - Everything in Python is a dictionary
        - `__dir__`
        - There are functions to access these inner things:
            - `vars`
            - `setattr(obj, a, 0) == obj.__dict__["a"] = 0 == obj.a = 0`
            - `hasattr`
- Sets
    - Set comprehensions and empty set
    - `frozenset` (built-in type)
    - Use & (intersection) operator to find multiple elements in set.
        - `len(set(needles).intersection(haystack))`
    - Create a `set` or a `frozenset` is a good use case for generators
- Under the hood
    - Explain hash tables: Upper part of hash to find bucket, lower part to resolve collisions
    - The hash() function is salted. The salt is constant at a process level.
    - Avg 1-2 collisions. 1/3 of the hash table empty
    - They are not memory efficient
        - But they are not as bad as they used to be: (See history below)
        - 2./ Keys were scrambled
        - 3.5 Randomised
        - 3.6 Ordered but not guaranteed by the standard
        - 3.7 Ordered guaranteed by the standard
- Design of a hash table
    - Taken from: https://www.youtube.com/watch?v=p33CVV29OG8
    - Separate chaining: Two buckets [[(hash, key, value), ...], [(hash, key, value), ...]]
        - It wastes empty buckets
        - Every list needs room to grow
    - Open addressing
        [(key, value), None, None, (key, value), None]
        - Linear probing
        - Gets rids of the extra lists
        - Catastrophic pile-up
    - Open addressing multiple pile-up
        - Random number generator (random probing)
    - Compact dict
        [list with (hash, key, value)]
        [pointer to position in list] # [0, None, 4, 3, None, None] -> 1 byte in size

